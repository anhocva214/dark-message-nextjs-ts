"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

const syncRef = (source, target) => {
  /* istanbul ignore else */
  if (typeof target === 'function') {
    target(source.current);
  } else if (target) {
    ;
    target.current = source.current;
  }
};

const BaseChart = (props, ref) => {
  const {
    chart: Chart,
    style,
    className,
    chartRef: chart
  } = props,
        restProps = (0, _objectWithoutProperties2.default)(props, ["chart", "style", "className", "chartRef"]);
  const chartRef = (0, _react.useRef)(null);
  const configRef = (0, _react.useRef)();
  const containerRef = (0, _react.useRef)(null);
  const isFirstRenderRef = (0, _react.useRef)(true);
  const dataRef = (0, _react.useRef)([]);
  (0, _react.useImperativeHandle)(ref, () => containerRef.current);
  (0, _react.useEffect)(() => {
    const {
      current: container
    } = containerRef;
    /* istanbul ignore else */

    if (container) {
      const _ref = restProps,
            {
        data
      } = _ref,
            config = (0, _objectWithoutProperties2.default)(_ref, ["data"]);
      configRef.current = (0, _cloneDeep.default)(config);
      const normalizedData = data || [];
      dataRef.current = normalizedData;
      const mergedConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
        data: normalizedData
      });
      chartRef.current = new Chart(container, mergedConfig);
      chartRef.current.render();
    }

    syncRef(chartRef, chart);
    return () => {
      /* istanbul ignore else */
      if (chartRef.current) {
        chartRef.current.destroy();
        chartRef.current = null;
        syncRef(chartRef, chart);
      }
    }; // eslint-disable-next-line
  }, []);
  (0, _react.useEffect)(() => {
    const {
      current: chart
    } = chartRef;
    /* istanbul ignore else */

    if (chart) {
      // avoid update in first time
      if (!isFirstRenderRef.current) {
        const _ref2 = restProps,
              {
          data
        } = _ref2,
              config = (0, _objectWithoutProperties2.default)(_ref2, ["data"]);
        const normalizedData = data || [];

        if (!(0, _isEqual.default)(config, configRef.current) || !dataRef.current.length) {
          configRef.current = (0, _cloneDeep.default)(config);
          const mergedConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
            data: normalizedData
          });
          chart.update(mergedConfig);
          chart.render();
        } else {
          chart.changeData(normalizedData);
        }

        dataRef.current = normalizedData;
      } else {
        isFirstRenderRef.current = false;
      }
    }
  }, [restProps]);
  return /*#__PURE__*/_react.default.createElement("div", {
    style: style,
    className: className,
    ref: containerRef
  });
};

var _default = /*#__PURE__*/(0, _react.forwardRef)(BaseChart);

exports.default = _default;